### Лекции по предмету ООП
### Университет: СПБГЭТУ "ЛЭТИ"
### Преподаватель: Власенко Сергей Владимирович
***
##### Объектно-ориентированный подход в программировании.

Понятие Объектно-ориентированного подхода распространяется на ряд наук, 
в том числе и на теорию программирования. 
Общий смысл подхода сводится к альтернативному способу построения модели данных и алгоритмов. 
В программировании данный подход проявляется в объектно-ориентированных и процедурных языках, 
как новый способ формирования пользовательских типов данных и способ общей организации программы.
 
###### Отличия от процедурного подхода:

+ При процедурном подходе работа программы рассматривается 
как *ЦЕНТРАЛИЗОВАННО* управляемая последовательность действий. 
Строго фиксирована по времени и последовательности исполнения. 
При объектно-ориентированном подходе программа рассматривается 
как совокупность действий независимых объектов, обменивающихся 
между собой информацией (то есть имеет место децентрализованное 
управление вычислительным процессом).

+ Структуры данных при процедурном подходе обрабатываются 
внешними по-отношению к ним процедурными компонентами, то есть 
исполняемый код и структуры данных разделяются не только физически, 
но и логически. 
+ При объектно-ориентированном подходе действия 
и структуры данных логически связываются в рамках единого объекта 
или типа объекта, то есть действия всегда рассматриваются 
применительно к конкретным структурам данных 
и наоборот структуры данных всегда рассматриваются 
применительно к конкретным действиям над ними.
 
###### Объектно-ориентированные алгоритмы.
+ Традиционные линейные программные алгоритмы не подходят 
к общему порядку организации структур данных и процедурных компонентов в ООП. 
+ В ранних классических работах по объектно-ориентированному подходу решение задачи 
рассматривалось как поиск алгоритма поведения объекта, при котором совокупность объектов, 
действуя по данному алгоритму позволит получить, решение исходной задачи.
+ Традиционным средством информационного обмена между объектами в ООП считался механизм обмена сообщениями. Равноправным способом был также обмен через разделяемую или так называемую общую память. 
+ Такой порядок обмена информацией предполагал соответственно и новый по-сравнению с процедурным программированием 
механизм синхронизации в рамках программы. В ООП синхронизации действия объектов исходно привязывалось к событийной модели времени. В процедурном же программировании модели времени всегда строго линейна.
 
###### Объекты и классы объектов.
+ В рамках объектно-ориентированного подхода исходно рассматривалось понятие класса. 
Класс в ООП - это тип объектов (соответственно объекты - это экземпляры класса). 
Соответственно способы действия объектов реализуемые в программе всегда привязываются к некоторому классу.
+ Класс в C++ рассматривается как совокупность декларативной и процедурной части, то есть класс описывает и данные, хранимые объектами класса и действия, которые может предпринимать объект для обработки этих данных.
+ Дополнительной способностью классов является управление порядком доступом к данным объекта из внешней среды (внешней по-отношению к объекту). 
+ Исторически основные элементы объектно-ориентированного подхода были реализованы в языках программирования:
```c++
Simula - 67, SmallTalk.
```
В настоящее время практически все наиболее распространенные алгоритмические языки программирования:
```c++
C, Paskal, Basic и др.
```
Имеют объектно-ориентированное расширение, для языка C таким расширением стал C++ (датируется 1992-1993 годом).
 
###### Общие свойства объектно-ориентированного подхода в C++.
Принято считать, что ООП строиться на трех базовых элементах:
 
1. Инкапсуляция - под инкапсуляцией понимается совмещение в понятии тип данных 
декларативных и процедурных описаний. В C++ инкапсуляция проявляется в том, 
что в описании класса выделяются СВОЙСТВА (данные, хранимые в объектах) 
и методы (функции, обрабатывающие данные) и свойства и методы являются членами класса. 
Соответственно обращаясь к объекту, программа может работать как со свойствами, 
так и с методами этого объекта. Все объекты одного класса имеют один и тот же состав 
свойств и методов, поскольку класс является типом объекта.
 
2. Полиморфизм - множество форм при одном и том же содержании. В C++ проявляется в нескольких формах:
- При так называемой перегрузке функций. Под перегрузкой при этом понимается 
использование одноименных функций, имеющих при этом разную сигнатуру. Сигнатура - совокупная характеристика 
```c++
int f(int, float)
```
то что мы декларируем, то есть g, объявленная 
```c++
int g(int, float)
```
имеет ту же сигнатуру что и функция f.
Пример:  	
```c++
int f(int);
int f(float);
y = f(x);
```
- Компилятор в зависимости от контекста (тип параметра х) выбирает, какую из них использовать
Один и тот же метод класса может по-разному вести себя в зависимости от того, 
с каким конкретным объектом класса этот метод работает, то есть имя метода не меняется, 
но его поведение различно. Аналогичная ситуация, только для класса. 
Особым случаем применения такого полиморфизма является случай с наследованием класса 
(то есть, случай с обработкой объектов имеющих схожую внутреннюю структуру и относящиеся, 
к так называемым родственным классам).
 
- Самостоятельным проявлением полиморфизма иногда считают механизм так называемых виртуальных функций. Механизм связан с понятием наследования, в отличие от предыдущих пунктов, виртуальные функции имеют полностью идентичную сигнатуру, но абсолютно различные физические реализации. Выбор конкретной реализации производится путем определения точного класса объекта из семейства родственных классов, связанных наследованием.
 
3. Наследование в C++ - это способность классов передавать часть или полный набор своих свойств и методов другим классам. Передающий класс считается классом предком, принимающие классы - классами потомками. В отличие от других языков C++ допускает так называемое множественное наследование, соответственно в языке возможно использование классов, которые:
* Имеют произвольное число классов-предков.
* Имеют произвольное число классов-потомков.
Единственным ограничением возможности наследования в C++ является запрет на создание иерархий наследования, в которых класс по какой-либо траектории наследования может стать собственным предком. Если представить иерархию наследования как ориентированный граф, указанный запрет можно рассматривать, как запрет на присутствие в этом графе каких-либо замкнутых циклов.
 
###### Технологические аспекты использования ООП в C++.
+ Объектно-ориентированный подход нашел широкое распространение в программировании в первую очередь потому, что позволил создать универсальную основу для построения одних программных продуктов на основе других. При использовании ООП, классы общего назначения могут наследоваться в производных продуктах, что открывает возможность существенной экономии объемов создаваемого кода. При этом в отличие от обычного использования внешних библиотек классы не являются черными ящиками и могут гибко встраиваться в новые приложения, кроме того настройка классов возможна на уровне исходных текстов программ. Это существенно отличается от случая, когда программа использует библиотеки объектного кода, ранее полученного компилятором.
 
###### Синтаксис использования класса.
Класс в С++ - это тип данных, который определяет:
1. Состав свойств и методов класса;
2. Порядок доступа к членам класса;
3. Внешними функциями имеющие привилегированный доступ к членам класса.
 
Декларация класса
```c++
class имя_класса: список наследования
{
	Декларация членов класса
};
```

Декларация членов класса
```c++
тип_доступа: декларация свойства / метода;
```

Список наследования состоит из разделенных запятыми элементов, каждый из которых имеет вид:
тип_наследования имя класса

Список наследования является необязательным элементом декларации класса.
При описании декларации члена класса элемент "тип_доступа" может быть опущен, если тип доступа совпадает с типом доступа предыдущего члена класса.
 
Типы доступа к членам класса.
В C++ определено три типа доступа:
1. public (открытый доступ) - означает, что свойства и методы класса, входящие в его открытую часть доступны для:
	а) методов класса
	б) для любых внешних функций
	в) для методов производных классов (при наследовании)
2. private (закрытый доступ) - к закрытой части класса имеют доступ только методы самого класса, а также внешнии функции,
объявленные внутри класса как "друзья" (ключевое слово friend)
3. protected (защищенный доступ) - защищенная часть класса, является частным случаем private. 
К защищенной части класса могут обращаться:
	а) методы и друзья этого класса;
	б) методы и друзья производных классов
 
### ПО УМОЛЧАНИЮ СЧИТАЕТСЯ, ЧТО ЧЛЕН КЛАССА ЯВЛЯЕТСЯ ЗАКРЫТЫМ(private)
 
```c++
struct = class {public:};
union = class {public:};
```
Структуры и объединения являются классами, в которых все члены по умолчанию являются открытыми.
 
Пример:
```c++
class X 
{
	int a; // закрытое по умолчанию
	public: int b;
	public: float c;
	protected: 
		int d;
		void f();
	private: int e;
	public: int h; // системы описания элементов нет т.е. можно
			        //хаотично менять порядки доступа
	public: void g();
};

void X::g() // функция g является методом класса X => внутри этой
		      // функции возможен доступ к любым членам класса
	      // (открытым, закрытым, защищенным)
{
	b = 1; // открытый член класса
	d = 1; // закрытый член класса
	e = 1; // защищенный член класса
	f(); // такой вызов вполне уместен
}

void main()
{
	X t;
	t.a = 1; // запрещенное обращение | a - закрытый член класса |
	t.b = 1; // нормальное обращение | b - открытый член класса |
	t.d = 1; // запрещенное обращение | d - запрещенный член класса |
	t.g(); // такой вызов возможен <= g - открытый член класса X
	t.f(); // такой вызов невозможен <= f - защищенный член класса X
}
```

###### Синтаксис обращения к членам класса
Синтаксис обращения к классам полностью аналогичен случаю struct и union и реализуется на базе операция . и ->
 
###### Синтаксис реализации методов класса
В отличие от обычных C функций методы класса:
	1. Имеют расширенное полное имя в котором перед именем функции содержится префикс:
	    	имя_класса::
	2. Обращения к свойствам и методам класса внутри метода класса не требует указания конкретного объекта, к которому
осуществляется доступ;
	3. Считается, что метод работает с тем объектом класса, из которого этот метод вызван.
 
###### inline функции
 
+ Если метод класса только продекларирован внутри декларации класса, то он интерпретируется как обычная C функция, привязанная к классу, если же внутри декларации класса описывается непосредственно реализация метода, то считается, что этот метод реализуется как inline функция.
+ inline функцией в C++ называется функция, в точке вызова которой компилятор непосредственно подставляет программный код самой функции (соответствующей контекстной заменой формальных параметров на фактические) во всех остальных случаях вызов функции означает "прыжок" (в assemblere называется jump) с передачей управления на первый операнд функции.
+ Таким образом для обычных функций код функции присутствует в коде программы в единичном экземпляре. Код же inline функций встречается в коде программы n раз, где n - количество вызовов функции.
+ Смысл использования inline функции состоит в экономии процессорного времени, источник экономии - отсутствие необходимости в дополнительных служебных операциях, которые осуществляются при вызове обычной функции (сохранение и восстановление контекста, запись параметров в стек, обработка точки возврата и т.п.)
 
+ Если функция имеет малый по объемам код "накладные расходы" на вызов такой функции могут в десятки раз превышать время работы самой функции (пример: сохранить регистр, порядка 20 инструкций).
+ В связи с этим иногда удобно реализовывать малообъемные функции в виде инлайн функций, при этом однако надо учитывать то, что если inline функция вызывается многократно, объем общего кода (машинного кода) программы может существенно увеличиваться и соответственно делать экономию процессорного времени не актуально.
 
###### Синтаксис inline функции:
```c++
class X
{
	public: void g() {b = 1;...}
	private: inline void t();
}
inline void X::t()
{
	std::cout << "t";
}
```
Актуально использовать, если функция мало кода и не очень много раз используется.
Визуально данное проявление можно увидеть хотя бы в том же дебаггере.
 
###### Физическая реализация методов класса
С точки зрения представления в программном коде методы класса являются абсолютно обычными C функциями. Привязка методов к объектам класса осуществляется за счет использования скрытого первого параметра функции. Этот параметр является указателем на объект, из которого вызывается метод. Соответственно в точке вызова метода компилятор определяет адрес соответствующего объекта и подставляет его значение в качестве первого параметра функции. Для обращения к этому не явному первому параметру метода внутри метода используется служебный идентификатор this (указатель на объект из которого вызван метод)
 
```c++
class X
{
	public: int b;
	public: void g();
};

void X::g()
{
	b = 1 == this.b = 1; // не это имеется в виду, мы говорим 
				        // о смысловой идентичности написания
}
```
по сути 

```c++
void X::(X*) // X* скрытый параметр для нас
{
	b = 1 == this.b = 1;
}
```
 
Пусть дан двусвязный список 
```c++
class Node 
{
	public: 
		void App(Node *p);
		Node *next;
		Node *prev;
};

void Node::App(Node *p)
{
	p = new Node;
	next = p;
	p->prev = this;
	this->next = p;
}
```

###### Друзья класса
Друзьями класса считаются внешние функции *НЕ МЕТОДЫ КЛАССА*, которым дается право доступа к закрытой и защищенной частям класса. Это разрешение указывается непосредственно в декларации класса. С использованием ключевого слова friend 
	
Пример:
```c++ 
class X
{
	int a;
	....
	public: int b;
	friend void w(X&);
}

	friend void w(X& s) 
{ 
	s.b = 1; 
	...; 
	s.a = 1; // корректно, т.к. функция - друг класса 
};
```

Друзьями класса могут является методы других классов:
```c++
class X
{
	friend void Y::Z();
	friend class V; // все методы класса V являются друзьями класса X
}
	// метод класса Y - является другом моего класса X

/* Начало вставки теории с практического занятия */
struct X // частный случай использования классов
{
	int ap[10];
	void f(); // пример описания метода класса X
};
```

В объекте X имеются члены данных:
массив ap;
метод - f(),
метод привязывается к конкретному объекту класса X

```c++ 
void X::f() 
{
	for (int i = 0; i < 10; ++i) {
		cin >> ap[i]; 
// обращение такое, потому что метод f привязан к конкретному объекту
		// и обращаться он будет именно к данным данного объекта
	}
}
 
void main() {
	X t;
	t.f();
}
/* Конец вставки теории из практического занятия */
```

###### Конструкторы и деструкторы.
+ Это специализированные ОТКРЫТЫЕ методы класса, которые автоматически запускаются в моменты
создания и удаления объектов класса соответственно. 
Под созданием и удалением понимаются моменты входа объекта в область видимости 
и выхода его из этой области.
+ И конструкторы и деструкторы обязательно должны объявляться в открытой части класса т.е. public.
 
###### Конструкторы.
Класс может иметь произвольное число конструкторов, при этом каждый конструктор должен иметь
уникальный набор параметров. Тип возвращаемого значения для конструкторов не указывается.
*Физически конструктор не явно возвращает указатель на создаваемый объект*
Все конструкторы имеют одно и то же имя, совпадающее с названием класса.
Пример: 
```c++
class X
{
public: 
	int *p; // динамический массив
	int N; // размерность p
	X(); // декларация конструктора без параметров
	X(int); // конструктор с одним параметром типа int
	X(X&); // специализированный конструктор,
		 // который называется конструктором копирования в инициализации
		 // обслуживает ситуацию создания объекта 
	void kek() {X a = b;} // а и b объекты класса Х
	~X(); // декларация деструктора класса Х
}
```

Синтаксис реализации конструкторов полностью совпадает со случаем обычных методов класса, 
за исключением отсутствия типа возвращаемого значения.
```c++
X::X()
{
	p = 0;
	n = 0;
}
X::X(int m)
{
	p = new int[m];
	N = m;
}
X::X(X& a)
{
	N = a.N;
	p = new int[N];
	for (int i = 0; i < N; ++i) 
		p[i] = a.p[i];
}

void main()
{
	X t; // запуск конструктора без параметров
	X d(3); // запуск конструктора с параметром типа int
	X f = d; // запуск конструктора копирования в инициализации
	...
}
```

	Выбор конкретного конструктора осуществляется компилятором на основании анализа контекста,
	в котором описывается создание объекта. Для приведенного примера точкой входа объекта в область
	видимости объекта является старт функции main, соответственно после её запуска конструкторы
	будут запускаться в порядке соответствующим последовательности декларарирования объектов класса Х.
	В стандарте строгой интерпретации работы конструктора нет т.е. запуск может работать по-разному.
	(т.е. в определенных компиляторах может быть пресоздание объектов, либо без нее, 
	так что желательно создавать в логичных местах объекты).

	В C++ допускается декларирование объектов внутри вложенных операторных блоков, в подобных случаях 
	точкой входа в область видимости является старт соответствующего операторного блока.

###### Деструкторы.
+ В классе может быть определен только один деструктор и этот деструктор не может иметь параметров.
Точкой запуска деструктора является точка выхода объекта из области видимости.
Имя деструктора предопределено и имеет вид:
~имя_класса  

Для примера класса X реализация деструктора могла бы иметь вид:
```c++
X::~X()
{
	N = 0;
	delete p;
}
```

###### Частные случаи использования конструкторов и деструкторов.
1. Конструкторы и деструкторы динамических объектов.
```c++
void main()
{
	X *g;
	g = new X; // в данном случае для нового объекта класса Х будет запущен конструктор без параметров
	...
	g = new X(5); // запущен конструктор X(int)
	...
	delete g; // точка запуска деструктора класса X
}
```
2. Динамические массивы объектов класса.
```c++
g = new X[10]; // для каждого из объектов запускается конструктор без параметров
... 
g = new X[10](5); // для каждого из объектов запускается конструктор X(int);
...
delete g; // для каждого из объектов запускается деструктор
delete []g; // рекомендуемая нотация - деструктор для каждого из объектов
3. Для случая статических массивов объекта классов картина полностью аналогична
X s[5]; // для каждого из объектов запускается конструктор без параметров
X s[5](5); // для каждого из объектов запускается конструктор X(int);
```

Деструкторы для объекта из массива s вызываются в точке выхода этого 
объекта из области видимости.

Объекты класса как члены другого класса.
Примеры:
```c++
class Y
{
	...
public:
	Y(int);
	X c; // то есть одним из свойств класса Y является объект класса X
	...
}
```

В случае, когда объект одного класса является членом другого класса(вмещающего) 
принят следующий порядок действий по созданию объектов:
Первым создается вложенный объект, для которого запускаются необходимые конструкторы,
затем запускаются конструкторы вмещающего класса.
В связи с этим возникает следующая проблема:
Как указать при декларировании объекта вмещающего класса какой именно из конструкторов 
должен быть запущен для объекта вложенного класса.
Пример:
```c++
void main()
{
	Y v(5); // какой конструктор использовать?
}
```
Для разрешения подобной проблемы в C++ реализован механизм передачи параметров 
из одного конструктора в другой 
		*из конструктора вмещающего класса в конструктор вложенного класса*
Такая передача параметров описывается при реализации конструкторов вмещающего класса.
Пример реализации конструктора вмещающего класса, который передает параметр 
в конструктор вложенного класса.
```c++
Y(int m): c(m + 1) // список параметра конструктора вложенного класса может содержать
				   // только выражения составленные из идентификаторов параметров
				   // конструктора вмещающего класса и констант
				   // т.е. можем использовать только m и констант
{
	...
};

class Y
{
public:
	Y(int);
	X c;
	X e;
	F f;
}
Y(int m): c(m + 1), e(m + 5, 1), f(m) // физически эти объекты создаются первыми
{ ... };
```
В случае, если вмещающий класс содержит несколько вложенных объектов другого класса,
то передача параметров этим конструктором описывается через запятую в том же заголовке
конструктора вмещающего класса.
Последовательность вызова конструктора для нашего примера:
```c++
X(int); // для c
X(int, int); // для e
F(int); // для f
Y(int); // для Y
```
 
###### Перегрузка операций.
В C++ существует возможность переопределения (программистом) симантики базовых операций
и языка для случаев, когда операндами этих операций являются объекты этих классов.

```c++ 
X a, b, c;
a = b + c;
```
Если бы эти операции не были переопределены, оператор был бы некорренктным *ни равно ни плюс, не приминимы к классам, структурам и др. по определению*.
Примечание: для struct and union в C++ предусмотрен смысл присваивания, он сводится к побитовому
копированию одного объекта в другой.
 
В C++ допускается перегузка всех стандартных операций, за исключением следующих:
```c++
new
delete
.
->
? :
* - унарный не перегруж, бинарный перегруж.
&
```
В некоторых реализациях языка, к операциям приравнивается sizeof(), который тоже не подлежит перегрузке.
Все остальные можно переопределить.

При перегрузке операций программист не может переопределить:
	1. Количество операндов операции (то есть все операции остаются унарными или бинарными)
	2. Приоритет операций в стандартной таблице приоритетов.

Перегрузка операций предполагает для унарных операций:
Единственный операнд является объектом класса.

Перегрузка операций предполагает для бинарных операций:
	Один операнд (первый левый) является объектом класса.

Пример:
```c++
X a, b, c;
int i;
a = b + i; // допустимо
a = i + b; // недопустимо
```

###### Перегрузки операций в классах:
Реализация перегрузок происходит с использованием специальных функций, имена которых строятся
по общему правилу:
*operator знак_операции*
Данные функции могут быть либо методами классов, либо функциями-друзьями в зависимости от того,
какой вариант перегрузки выбран функции имеют то или иное количество входных параметров.
Порядок интерпретации вызовов перегружающих функций зависит от двух факторов:
	1. *арность операции.
	2. Способ перегрузки (метод или друг).

Пусть перегружен operator # для объекта a
```c++
a++

operator ++
// интерпретации
Унарный метод {
	a.operator #(); // 0 параметров
}

Унарный друг {
	operator #(a); // 1 параметр типа X&
}
Запись в тексте программы
	a#

a + b
Бинарный метод {
	a.operator #(b); // 1 параметр произвольного типа T
}
Бинарный друг {
	operator #(a,b); // 2 параметра
}
Запись в тексте программы
	a # b
```

###### Примечание:
В ряде реализаций C++ перегрузка бинарных операций допускается только с использованием функций-друзей.
В ряде реализаций C++ существует возможность использования различных перегрузок отдельно для каждой
формы унарных операций -- ++ (для префиксной и постфиксной). 
Эти случаи являются исключением для общего правила:
Перегрузка *КАЖДОЙ* операции в классах должна быть уникальной. Под уникальностью понимается в даннном
случае набор типов операндов перегружаемой операции.

Пример:
1.
```c++
operator + (int) // params: X, int
operator + (float) // params: X, float
operator + (int) // incorrect
```
2.
```c++
class U
{
	void operator+(int);
	friend operator + (U&, int);
}
```

```c++
void operator + (U&, int); // некорректно, поскольку набор типов параметров одинаков
```
При этом не важно, каким именно из способов (методом или другом осуществляется перегрузка).

```c++
class X
{
public:
	int *p;
	int n;

	X operator + (X&); // перегрузка бинарной операции плюс, с использованием метода класса
	friend X operator * (X&, X&); // попарное суммирование элементов массива
	X operator = (X&); // перегрузка оператора присваивания методом класса
	...
}
```
###### Примечание:
Типы возвращаемых значений в перегружаемых операциях могут быть произвольными.
Например:
В приведенном классе X возвращаемый типо операции + может сделать void, 
тогда в программе можно будет использовать вызов 
```c++
b + c;
```
Но будет запрещен
```c++
a = b + c; // поскольку b + c не будет возвращать
```

Реализация:
```c++
X X::operator + (X& t)
{
	X sum;

	sum.n = n + t.n;
	sum.p = new int [sum.n];

	for ( int i = 0; i < n; ++i ) {
		sum.p[i] = p[i];
	}

	for ( int i = 0; i < t.n; ++i ) {
		sum.p[n + i] = t.p[i];
	}

	return sum;
}
```
###### Примечание:
Рекомендуется в случаях создания объектов внутри перегружающих функций
возвращать сам объект, а не ссылку на него.

```c++
X operator * ( X& a, X& b )
{
	X sum;

	if ( a.n == b.n ) {
		sum.n = a.n;
		sum.p = new int [sum.n];
		for ( int i = 0; i < sum.n; ++i ) {
			sum.p[i] = a.p[i] + b.p[i];
		}
	} else {
		return 0;
	}

	return sum;
}

X X::opeartor = (X& t) 
{
	n = t.n;
	if ( p )
		delete p;
	p = new int [t.n];
	for ( int i = 0; i < t.n; ++i ) {
		p[i] = 0;
	}
	return *this;
}
```
Для того чтобы делать множественное присваивание 
 
Особый случай перегрузки операторов
Перегразука операторов индексирования.
Идексирование в C++ при этом вторым операндом считается индекс. 
Механизм перегрузки операторов позволяет многократно переопределять индексирование для различных типов индексов.

```c++ 
Тип_возвращаемого_значения operator (индекс);
int operator[] (int);
 
class X
{
public:
	int *arr;
	int size;
	// friend int operator[[] (X&, int); 
	int operator[] (int) { ... }
}
 
int X::operator[] (int i)
{
	return arr[i];
}
 
int operator[] (X& a, int i)
{
	return a.arr[i];
}
```
Перегрузка индексирования часто используется для реализации в классе возможности ассоциативной индексации.

Пример:
```c++
class Y
{
public:
	...
	char *lastName[];
	int mark[10];
	int operator[] (char *); // вернуть оценку по зааданной фамилии
}

int Y::operator[] (char *lastName)
{
	int i, j, k;
	for (int i = 0; i < 10; ++i) {
		if (strcmp (s[i], lastName) == 0) {
			return mark[i];
		}
	}
}

void main()
{
	char *d;
	Y a;
	cin >> d;
	cout << a[d]; // оценка по заданной фамилии
}
```

###### Перегрузка оператора вызова функции.
Вызов функции рассматривается как бинарная операция, в который вторым операндом является список выражений, 
описывающих фактические параметры вызова функций. Исходя из данного определения следует, что произвольный
набор типов фактических параметров можно рассматривать как уникальную сигнатуру для перегружающей функции.
Соответственно операция вызова функции может перегружаться произвольное число раз для различных сигнатур.
Однако на практике, как правило, такие перегрузки не используются, наиболее распрространенный вариант
применения - перегрузка вызова функции с пустым списком параметров.
Типичным примером таких перегрузок являются так называемые классы-итераторы, которые используются совместно
со структурами данных последовательного доступа:
+ Итераторы списков.
+ Итераторы деревьев и т.д.

```c++
X operator() (); // X a; ...; a();
// Осуществим перегрузку оператора вызова функции, когда один параметр вызова функции

X operator() (int); // X a; ...; a(5);

friend X operator() (X&) // перегрузка вызова функции без параметра
```

###### Пример организации класса-итератора для односвязных линейных списков

```c++ 
struct Node
{
	int info;
	Node *link;
};
 
class List
{
public:
	List();
	Node *Top; // указ на голову очереди
	...
	ListIter a;
};
 
class ListIter
{
	public:
		Node *current; // указ на текущую позицию в списке
		Node * operator() (); // данный метод предназначается для того, чтобы осуществить сдвиг из текущей позиции списка в следующую
		Node * operator++ (); // для сдвига на один элемент
		// в теле перегруженной операции изменяется текущяя позиция списка
		...
		List_iter(List a) {
			current = a.Top;
		}
 
}; 
 
List::List()
{
	Top = 0;
	a(*this);
}
```
 
+ Объект класса итератор часто помещают в основной класс, в данном примере в класс List, тогда в объекте класса List
появляется возможность непосредственно обращаться к объекту типа итератор, однако возможна и внешняя реализация итератора.
+ Конструктор итератора обычно используется для того чтобы связать конкретный объект-итератор с конкретной индексруемой структурой.
+ Тогда в конструкторе основного класса (в данном случае в List) описывается дополнительное создание соответствующего объекта-итератора.
 
```c++
current = p;
typeof(p) === Node *
current = current->link;
```

Тогда открывается возможность следующего использования итератора

```c++
void main()
{
	List t;
	t.a(); // сдвиг текущей позиции в списке
	t.a++; // сдвиг текущей позиции в списке

}
```
для того, чтобы не обращаться к вложенному объекту-итератору соответсвующую операцию перегружают и в основном тоже.
```c++
List List::operator++()
{
	a++;
}
```
 
+ Плюс заключается в том, что во внешней программе не требуется хранить в специальных переменных текущую позицию в списке,
эта текущая позиция хранится внутри итератора и там же обслуживается.
+ Достаточно часто для списочных структур используются и перегрузка индексирования, которая позволяет сделать список синтаксическим аналогом массива.
 
ее можно определить так
```c++
Node * operator[] (int);
``` 
и реализовать так
```c++
Node * List::operator[] (int i)
{
	for (int i = 0; i < size; ++i) {
		*this++;
	}
	return this->a.current; // для случая, если Top устанавливается в конструкторе или других методах и копируется в итератор а
}

void main()
{
	List s; 
	...
	for (int i = 0; i < 5; ++i) {
		cout << s[i]->info;
	}
}
```
 
###### Наследование.
+ Под наследованием в c++ понимается способность классов передавать из одного класса в другой (частично или полностью)
свойства и методы. При этом передающий класс называется базовым, а принимающий производным. При реализации концепции
наследования в c++ принято единственное существенное ограничение:
	В иерархии наследования запрещены траектории наследования, которые приводят к ситуации, когда некоторый класс
	через связи наследования становиться собственным предком. В c++ в отличае, например, от java допускается 
	множественное наследование т.е. некоторый производный класс может иметь произвольное количество базовых классов.
	Связанные отношением наследования классы могут образовывать иерархию, которые геометрически могут отображаться
	ориентированными графами.

+ Общая идея наследования.
		Основные преимущества наследования заключаются в возможности экономии времени на разработку приложений,
	в отличае от подходов, связанных с использованием библиотек наследование в ООП позволяет гораздо более гибко
	использовать уже созданное программное обеспечение, а также интегрироваться с ним на уровне представления данных.
	То есть классы наследуют не только процедурную составляющую, но и структуры данных базового класса.
	При этом использование наследования в организационном плане упрощает декомпозицию разработки на отдельные,
	логически завершенные компоненты.
		Дополнительным способом применения наследования в c++ можно считать построение и обработку неоднородных
	структур данных. Такие возможности обеспечивают наличие (родственных связей между базовыми и производными классами).
	Все подобные классы, "относящиеся к одному семейству" могут образовывать единые связные динамические структуры,
	не смотря на то, что формально каждый класс в иерархии является полностью самостоятельным типом данных.
	Других вариантов эффективной обработки неоднородных структур данных в языках программирования нет.

+ Физическая реализация наследования в c++.
	Физическая модель наследования в c++ сводится к тому что в объектах производных классов физически внедряются
	подобъекты базовых классов. Методы базовых классов доступны как и любые внешние функции, однако, на использование
	базовых свойств и методов базовых классов накладываются ограничения, регламентируемые порядком доступа к членам класса.

+ Виды наследования в c++.
Виды наследования в c++ регламентируют права доступа к членам базового класса в производном классе.
В c++ выделяются три вида наследования по аналогии с общими порядками доступа к членам класса:
```c++
public
private
protected
```

###### Регламенты доступа определяются в связи со следующими правилами:

***

|Вид наследования|Права доступа|Регламент доступа|
|----------------|-------------|-----------------|
|Public|Public|Public|
|Public|Private|-|
|Public|Protected|Protected|
|Private|Public|Private|
|Private|Private|-|
|Private|Protected|Private|
|Protected|Public|Protected|
|Protected|Private|-|
|Protected|Protected|Protected|

###### Синтаксис описания наследования.
Обычная реализвация класса
```c++
class X : <список наследования>
{
	...
};
```
*<список наследования>* состоит из элементов разделенных запятыми, каждый элемент имеет описывает базовый класс
и вид наследования от этого класса.

```c++
class X: public Y, protected Z
{
	...
};
```

Если вид наследования не указывается, то по умолчанию он private. Исключение составляют частные случаи классов 
- struct and union
```c++
запись struct X: Y
{
	...
}; означает открытое наследование от Y, поскольку в struct and union возможны только открытые члены классов
```
единственным видом наследования, которые к ним применимы является public, при этом базовый класс для
struct or union так же должен быть полностью открытым.

особенности прав доступа
к private может только внутренние функции исходного класса и друзья
к protected могут еще унаследовавшие классы использовать

В производном классе для методов и друзей этого класса имеется возможность доступа к защищенной части базового класса,
но не имеется возможности к закрытой части базового класса.

```c++
class X
{
public:
	int apub;
	void fpub();
private:
	int apri;
protected:
	int apro;
};

class Y: public X
{
public:
	void fypub();
	...
}

void Y::fypub()
{
	apub = 1; // доступ к членам базового класса в произовдном классе описывается без каких-либо префиксов,
	// поскольку члены базового класса физически присутствуют в объектах производного класса
	apri = 1; // некорректно
	apro = 1; // корректно, защищенный член доступен в производном классе, но недоступен во внешней функции
}

class V: protected X
{
public:
	void fvpub();
}

void V::fvpub()
{
	apub = 1; // допустимо 
	apro = 1; // допустимо
	apri = 1; // некорректно
}

void main()
{
	Y t;
	t.apub = 1; // корректно, поскольку apub является открытым членом базового и производного классов, то я имею доступ
	// во внешней функции
	t.apro = 1; // некорректно
	t.apri = 1; // некорректно т.к. он закрытый член в базовом классе. Не имеет значение какой вид наследования
	X z;
	z.apub = 1; // корректно
	z.apri = 1; // некорректно
	z.apro = 1; // некорректно

	V d;
	d.apro = 1; // некорректно
	d.apub = 1; // некорректно
}
``` 
 
###### Особые случаи передачи наследственных свойств.
Стандартная передача прав доступа члену базового класса полностью описывается таблицей предыдущей лекции,
однако, в C++ имеется возможность дополнительного управления правами доступа в производном классе при наследовании.
Особым случаем является передача прав при закрытом и защищенном наследовании, случай распростроняется на открытую
часть базового класса:

```c++
class X
{
public:
	int t;
	...
	void copy(&X);
};

class Y: private X
{
	X::t; // по стандартной процедуре открытый член базового класса t должен был бы стать закрытым членом класса Y
	// (поскольку используется закрытое наследование)
	// однако декларация X::t в открытой части производного класса позволяет сделать t открытым членом этого класса,
	// при этом физически нового свойства не создается, а лишь изменяются права доступа члену класса 
};

void main()
{
	Y z;
	z.t = 1; // допустимо, т.к. теперь t открытый член
}
```

Аналогично обстоит дело и с защищенным наследованием, таким же способом можно открыть защищенную часть
базового класса унаследованную из открытой части базового класса.

Базовый принцип совемстимости указателей на базовые и производные классы.
```c++
void X::copy(X& a);
{
	t = a.t;
}

class Y: public X
{
	...
};

void main()
{
	Y z, w;
	...
	z.copy(w); // в C++ в производном классе методы базового класса становяться "рабочими",
	// в связи с тем, что компилятор автоматически реализует преобразование типов,
	// при работе, связанной с наследованием.
}
```

+ В приведенном примере метод copy по определению имеет в качестве первого неявного параметра 
указатель типа X*, поскольку метод принадлежит классу X, однако метод доступен и в объектах
производного класса(из-за наследования), соответственно допустим и вызов z.copy(w); 
где z относится к классу Y, при таком вызове на вход метода подается параметр типа Y*,
а не X*, соответственно без автоматического преобразования Y* => X* метод запустить
было бы не возможно. Данный механизм и называется базовым принципом совместимости
указателей на базовый и производный классы.

+ Формулировка базового принципа.
Указатель на производный класс может быть автоматически(неявно) преобразован к типу
указателя на базовый класс, обратное преобразование может быть только явным.

+ Почему нельзя автоматически обратно преобразовать, потому что не понятно к какому типу преобразовывать.

```c++
void main()
{
	A xa, *pa; // A - базовый
	B xb, *pb; // B : public A
	C xc, *pc; // C : public B
	pa = &xb;

	pb = &xa; // некорректно, неявным быть не может
	pb = (B*) &xa; // корректное преобразование
	// рекомендуется рекомендацией явного преобразования типов осуществлять в правой части оператора присваивания
	(A*)pb = &xa; // тоже самое, но нерекомендуемо
}
```
Особые случаи преобразования указателей:
```c++
class X
{
public:
	int t;
	...

}

void main()
{
	Y z;
	z.t = 1; // некорректно

	X* p;
	p->t = 1; // работает
}
```

+ Совместимость типов указателей может порождать некоторые проблемы с правами доступа к открытой части базового класса.
В связи с этим не рекомендуется использовать совместимость указателей вне реализвации методов классов.

+ Общие подходы к организации иерархий классов.
В связи с возможностью наличия множества производных классов у одного базового класса, 
автоматическое преобразование указателей на производные классы к типу "указателя на базовый класс".
Приводят так называемые потери типа(конкретного производного класса) в методах базового класса.
То есть метод базового класса не в состоянии самостоятельно определить, 
с каким именно из произвольных классов он работает. В связи с этим возникает следующая проблема:
как осуществлять методами базового класса обработку данных, зависимую от конретного производного класса.

+ Решение этой проблемы определяет два основных возможных подхода к организации наследственных иерархий классов в C++.
	1. Шифрование типа.
	2. Механизм виртуальных функций.

###### Общая идея первого подхода состоит в следующем:
+ В подобъекте базового класса создается специальное свойство, в котором шифруется производный класс,
анализируя значение данного свойства методы базового класса могут определить с каким классом работают.
Само свойство "шифр" в свою очередь заполняется методами производного класса, 
обычно конструкторами.

Второй подход связан с механизмом, так называемых, виртуальных функций.

###### Виртуальные функции.
+ Механизм виртуальных функций в C++ сводиться к следующей идее - виртуальная функция объявляется в базовом классе,
в котором полностью задается ее сигнатура, каждый производный класс при этом получает право иметь собственню 
уникальную реализацию данной виртуальной функции. Сигнатура функции должна при этом строго соответствовать 
декларации базового класса, таким образом виртуальная функция может иметь произвольное количество реализаций,
не превышающее количество производных классов + 1 (единица, за счет того, что базовый класс может иметь
реализацию виртуальной функции)

+ Смысл создания множественных реализаций виртуальной функции сводиться к тому, что компилятор автоматически
определяет из объекта какого именно производного (или базового) класса вызывается функция и выбирает
соответствующий экземпляр виртуальной функции, соответсвующий данному классу. 
+ В отличае от подхода с шифованием типа явный анализ наименования класса не производится. 
Эти действия переходят в функции компилятора.

###### Синтаксис виртуальных функций.

```c++
class A
{
	public:
		virtual void out(); //  virtual используется только в базовом классе
};

void A::out() {};

class B : public A
{
	public:
		int x;
		void out(); // редекларация функции в производном классе
};

void B::out() 
{
	std::cout << x << std::endl;
};

class C : public A
{
public:
	float y[3];
	void out();
};

void C::out() 
{
	for (int i = 0; i < 3; i++) {
		std::cout << y[i] << std::endl;
	}
};

void main()
{
	A* t [3];
	A z;
	B v;
	C w;
	...
	t[0] = &z; // Указатель на тип A
	t[1] = &v; // Указатель на тип B
	t[2] = &w; // Указатель на тип C

	for (int i = 0, i < 3; i++) {
		t[i]->out();
	}

}
```

+ В точке вызов t[i]->out() происходит авотматическое определение типа объекта, на который указывает t[i],
в соответствии с этим типом выбирается кокретный экземпляр виртуальной функции.

+ *ЕСЛИ В КАКОМ ЛИБО ИЗ ПРОИЗВОДНЫХ КЛАССОВ* virtual function не определена, то для объектов этого класса
вызывается экземпляр функции из базового класса.

```c++
class D : public A
{
	// отуствует out()
};

void main()
{
	D m; m.out(); // то будет вызвана функция базового класса A::out
}
```

###### Механизм шифрование типа.
Примеры реализации:
```c++
class A
{
public:
	// шифр обязательно в открытой части класса
	char code; // поле будет хранить шифр типа объекта
	A() {
		code = 0;
	};
	...
};

class B : public A
{
public:
	int ax;
	B() {
		code = 1;
	};
	...
};

class C : public A
{
public:
	float bx;
	C() {
		code = 2;
	};
	...
};
```
+ Методы любого из классов A, B, C имеют доступ к полю code, соответственно в любой момент времени,
имея указатель типа A* имеется возможность проверить значения поля code и определить с объектом
какого из классов в настоящий момент работает метод.
Пример:
```c++
A* p = &v;
p = &v;

if (p->code == 1) {
	p->ax = 0;
}

if (p->code == 2) {
	p->bx = 1.5;
}
```

+ В произвольный момент времени, имея указатель на базовый класс, можно через этот указатель
проанализировать поле code и понять, с какого типа объекта мы работаем в данный момент(A, B или C)
и в зависимости от этого выполняются те или иные действия.

```c++
void A::f() 
{
	if (code == 1) {
		ax = 0; // некорректно
		(B*)this->ax = 0;
	}
};
```

+ Из данного примера следует, что в базовую часть класса можно перенести практически любой код,
обрабатывающий объекты производных классов. При этом общая тенденция ведет к так называемому
*Толстому базовому классу*. В свою очередь механизм виртуальных функций тяготеет к
*Тонкому базовому классу*.

###### Преимущества и недостатки двух подходов:
Минусом механизма шифрования типа является то, что в коде растут накладные расходы 
на анализ шифра типа, особенно большой программа становиться, когда наследуемых классов множество.
Добавление нового производного класса в иерархию при этом ведет к значительному объему изменений
в коде базового класса. Соответственно снижается общая выгода от повторного использования кода
базового класса. 
+ Основная мысль - создание нового производного класса не возможно без изменения базового.
Плюс подхода с шифрованием типа - незначительный объем работ, реализуемых в производном классе.

+ Плюсы механизма виртуальных функций противоположны случаю шифрования типа - новый класс, 
легко стыкуется с базовым и не требует редакции базового.
- Минус - обилие кода в производном классе.

###### Комбинированный подход
+ Комбинированный подход - при комбинированном подходе информационную часть стремяться разместить
в базовом классе, тогда производные классы работают с одним и тем же информационным подобъектом.
Но могут *ИНТЕРПРЕТИРОВАТЬ* его по-разному и по-разному обрабатывать. 
Сам информационный подобъект обычно реализуется при этом с использованием "универсальных" типов данных.
К таким типам в C++ относятся:
	void - неопределенный тип
	char - минимально адресуемый тип данных

+ Тогда, оперируя указателем void* или char* можно имитировать обращение к любому другому базовому
или пользовательскому типу данных. Для этого необходимо лишь преобразовать указатель к нужному типу.
То к какому именно типу приводиться указатель ОПРЕДЕЛЯЕТ ПРОИЗВОДНЫЙ КЛАСС.

+ Общая идея комбинированного подхода - основной объем кода реализуется в базовом классе,
где обработка информации ведется на структурном уровне. 
При этом операции чувствительные к типу информационной части описываются виртуальными функциями 
и реализуются в производном. Однако объем их кода относительно не велик.
Если подобную декомпозицию удается осуществить, комбинированный подход выигрывает 
и у подхода с шифрованием типа и у подхода с виртуальными функциями.

***

### Курсач
Построение иерархии из двух классов Абстрактная матрица -> Конкретная матрица.
Конкретная матрца (int), Конкретная матрица (float), Конкретная матрица (char)
 
Пример 
массив 32 байта хотим 1-4 байта и 5-8 сложить и закинуть в 9-12
```c++
int a = (int*)p;
int b = (int *)(p + sizeof(int));
(int*)(p + 2*sizeof(int)) = a + b;

p + i*sizeof(T) - адрес i-го эл-та типа T в исходном массиве char
```

###### Курсовая имеет общую и персональную части задачи.
Общая часть задания - реализовать иерархию классов "Абстрактный класс матриц" -> Матрица вещественных 
В данной иерархии необходимо реализовать:
	1. Конструкторы (создание матрицы заданного размера), 
	конструктор копирования в инициализации, конструктор без параметров.
	2. Деструктор
	3. Перегрузку операций присваивания
	4. Перегрузку операций сложения матриц +
	5. Методы консольного ввода / вывода
	6. Методы файлового ввода / вывода
	7. Прочие операции в персональном задании
Требование:
	1. Программа должна поддерживать консольное меню
	2. Основной объем кода максимально должен быть в базовом классе
	3. Матрицы квадратные, но размерность их неопределена
	В базовом классе не может фигурировать слово float 
 
*ВСЯ ИНФОРМАЦИОННАЯ ЧАСТЬ + ИНФОРМАЦИЯ О РАЗМЕРЕ ДОЛЖНА НАХОДИТСЯ В ИСХОДНОМ*
*ВСЯ ФУНКЦИОНАЛЬНАЯ ЧАСТЬ В ПРОИЗВОДНОМ*
 
```c++
void main()
{
	FloatMatr x, y, z;
	z = x + y;
}
```
 
Неоднородные структуры данных
 
Реализация на базе наследования
 
Проблема организации неоднородных структур данных
 
Студент – описывается своим набором параметров
 
Преподаватель – описывается своим набором параметров
 
Но и те и другие - работающие в вузе(запихнуть в список)
 
```c+++
struct stud
{ ... }
 
struct prep
{ ... }
 
struct worker
{
	void* next;	 
	char type;
	worker* link;
};
```

Универсальный тип void* для указания на объекты произвольных типов. Проблема на уровне семантики заключается в том что обратиться по указателю void* к объекту невозможно. Для такого обращения необходимы явные преобразования типа void* к типу t*, где t – Тип объекта
 
Сложно с шифрованием и дешифрованием части. Кроме того значительный объем операций связан с преобразованием указателя на инф часть

```c++ 
if (p->type == 1) {
	cout << ((student*) p-> info) -> fio;
} else {
	...
}
```
 
+ Проблема значительно усложняется при увеличении числа типов. Альтернативным способом могло бы являться прямое погружене типов stud и prep в узлы списка, однако синтаксически такое не возможно.
 
+ Реализация структур с использованием наследования
 
###### Общие идеи подхода:
 
+ Некоторый базовый класс сопоставляется со связями которые образуют не однородную струтуру из однотипных элементов. Все типы объектов присутствующие в данной структуре наследуют от этого базового класса. Соответственно физически в любом из типов структуры образуется объект хранщий информацию данного элемента структуры. Указанный подхол может использоваться при любых топологиях неоднородной структуры данных (списки/деревья/сети). Функциональная обработка элементов неоднородной структуры при этом обычно связываются с виртуальными функциями, которые декларируются в базовом классе(классе связи) и переопределяются в производных классах(классов элементов структуры) в зависимости от типа элемента структуры.
 
Пример реализации подхода для случая неоднородных линейных списков:
 
Требуется обслужить список информационная часть узлов которого тип а или б

```c++ 
struct A – класс A в котором все паблик(или рейтинг(типо шутка)))
 
struct A : Link // = (struct A : public Link)
{
	Float x;
	Float sum() {return x; }
	Void show() { cout << x; }
}
 
struct B : Link
{
	int y[s];
	Float sum() { ... }
	void show() { ... }
}
 
class List
{}
 
class Link // класс связей в неоднородном лин списке
{ 
public:
	Link* next;
	virtual float sum();
	virtual float show();
};

```

+ Для разных узлов списка будет разный метод рассчета. Мне лень дальше и было код записывать
 
+ Следствием совместимости указателей является то что указатель на базовый класс может указать на объект любого из производных классов. Потому что в объекте любого производного класса есть подобъект базового класса. Таким образом p может перемещаться оп неоднородному спикску от узла к узлу. Тип конкретного узла становится важным только в момент вызова вирт функции. В этой чке компилятор и исполниельная система определяют на какой именно тип указывает p и в соостветствии с этим выбирают нужную реализацию виртуальной функиции
 
 
+ Сложные неоднородные структуры
Вне зависимости от топологии неоднородной структуры данных, ее реализация на базе наследования
строиться на тех же идеях, что и в случае списка. Базовым классом объявляется тип связей в структуре.
Разнотипные узлы структуры наследуют от этого базового класса, функции поэлементной обработки
узлов структуры реализуются как виртуальные методы в базовом и производном классах.
На примере дерева:
```c++
class Link
{
	Link *next;// ------------------------------ зачеркнуть
	Link *left;
	Link *right;
	virtual ... // блок виртуальных функций для обработки дерева
};

class TreeNode : public Link
{
	int x;
	void f(); // блок перегрузки виртуальных функций, определенных в линк
};

class TreeNode2: public Link
{
	float y;
	void f();
}
```

Топология не важна, структура не важна, все реализуется в базовом классе

###### Абстрактные классы.
+ При использовании наследовании применяется понятие абстрактного класса. В некоторых реализациях C++
для явного указания на абстрактный класс используется ключевое слово abstract.

+ Строго под термином абстрактный класс подразумевается класс, неимеющий свойств и имеющий только виртуальные методы.
Такие классы используются только для того, чтобы обеспечить построение некоторой иерархии классов.
В которой и информационная и процедурная составляющие реализуются только в производных классах.
На практике в абстрактные классы иногда вводяться и не виртуальные методы.

###### Шаблоны template 
+ Шаблоны в поздних версиях C++ стали стандартным выразительным средством. Некоторые элементы механизма
реализовывались с использованием стандартных макросов, выполнением их препроцессором языка.
По физической природе своей работы шаблон template являются средствами описания исходного кода. // ... 

+ Шаблоны обрабатываются на фазе работы препроцессора языка.

+ В поздних версиях C++ шаблоны стали достаточно мощным инструментом, позволяющим значительно экономить
трудозатраты разработчика. С точки зрения эффективности работы самой программы templates являются 
негативным фактором, их использование приводит к значительному росту объема программного кода
и к усложнению работы исполнительной системы языка. С этой точки зрения использование шаблонов 
уступает, например, механизму наследования.

+ Понятие шаблона - шаблоном можно считать параметризованную сущность(тип данных или функцию),
для которой параметром могут являться идентификаторы типов данных.
Примечание: 
в самом общем случае параметрами шаблона, помимо типов данных могут быть:
	переменные
	симовльные строки
	константные выражения
То что тип является в шаблоне параметром позволяет создавать семейство типов данных,
имеющих схожую функциональность, но отличающихся типом обрабатываемых объектов.
При этом программист непосредственно реализует только сам шаблон(в одном экземпляре),
из этого шаблона по необходимости генерируется программное описание для всего семейства
типов данных, связанных с шаблоном. Генерация происходит с потребностями конкретной программы,
в которой явно используется типы-экземпляры соответствующие общему шаблону.

###### Синтаксис шаблона
1. Шаблоны классов

<class T> - параметры передаваемых типов, количество которых неопределено
T - идентификатор параметра, рассматривается далее в рамках описания декларации
шаблона как полноценное имя типа данных
```c++
template <class T> class Matrix
{
	public:
		T* info;
		int n;
		void f();
		T g();
};

template<class T>
void Matr<T>::f()
{
	...
};

struct A
{
	...
	void operator[](int);
	...
};
```

Использование шаблона в программе:
```c++
void main()
{
	/*
	В тексте программы, использующей шаблоны типов данных 
	идентификатор экземпляра шаблона(например Matr<int>) 
	являются абсолютно полноценными идентификаторами типов данных,
	соответственно могут описываться указатели на тип экзмепляр-шаблона,
	ссылки и тому подобое, кроме того описание шаблона может применяться
	при создании других типов данных, в частности шаблоны могут указываться
	в списках наследования в описаниях типов параметров функции и так далее.+
	*/
	Matr<int> x;
	Matr<float> y;
	Matr<A> a; // можно итерировать как с массивом
};
```

2. Шаблоны функций.

```c+++
template<class X> void sort(X* a, int n);

void main()
{
	int B[10];
	float M[20];
	sort(B, 10);
	sort(M, 20); // в большинстве реализаций языка явное указание шаблона-функции не требуется как в приведенном примере
	// компилятор определит тип с которым вызывается функция-шаблон автоматически генерируя необходимый экземпляр шаблона.
	// в некоторых реализациях такое явное указание требуется 
	// и вызовы имели бы вид
	sort<int>(...)
	sort<float>(...)
	// но это редко используется
	... 
}
```

В некоторых случаях бывает необходимы специальные реализации шаблонов для конкретных значений параметра шаблона.
Пусть, например, для случая класса-шаблона Matr необходимо отдельно реализовать класс Matr, 
	где T === Matr (тождественно равно)
Тогда существует возможность помимо общих шаблонов создать частную его реализацию. 
Только в этом случае генерация будет происходить единожды, в других же случаях генерация происходит
по средствам copy paste.


